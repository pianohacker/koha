#!/usr/bin/perl
#
# Copyright 2014 ByWater Solutions
#
# This file is part of Koha.
#
# Koha is free software; you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation; either version 3 of the License, or (at your option) any later
# version.
#
# Koha is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with Koha; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

use Modern::Perl;

use C4::Biblio qw();
use C4::Context;
use C4::ImportBatch qw( AddBiblioToBatch AddImportBatch GetImportRecordMarcXML ModBiblioInBatch );
use C4::Service;
use DateTime;
use DateTime::Format::Strptime;
use Encode qw( encode_utf8 );
use Koha::Database;
use MARC::Record;

my ( $query, $response ) = C4::Service->init( tools => 'manage_staged_marc' );

sub _parse_005_timestamp {
    my ( $timestamp, $default_to_end ) = @_;

    # YYYYMMDD
    if ( $timestamp =~ /^\d{8}$/ ) {
        my $parser = DateTime::Format::Strptime->new( pattern => '%Y%m%d' );
        my $timestamp = $parser->parse_datetime($timestamp);
        if ( $timestamp && $default_to_end ) {
            $timestamp->set(
                hour => 23,
                minute => 59,
                second => 59
            );
        }

        return $timestamp;
    # YYYYMMDDHHMMSS
    } elsif ( $timestamp =~ /^\d{8}\d{6}$/ ) {
        my $parser = DateTime::Format::Strptime->new( pattern => '%Y%m%d%H%M%S' );
        return $parser->parse_datetime($timestamp);
    }
}

sub download_batch {
    my ( $batch_id ) = @_;

    my $schema = Koha::Database->new()->schema();

    my %extra_conditions;

    my $start_control_number = $query->param( 'start_control_number' );
    my $end_control_number = $query->param( 'end_control_number' );

    if ( $start_control_number && $end_control_number ) {
        $extra_conditions{control_number} = { -between => [ $start_control_number, $end_control_number ] };
    }

    my $start_timestamp = $query->param( 'start_timestamp' );
    my $end_timestamp = $query->param( 'end_timestamp' );

    if ( $start_timestamp && $end_timestamp ) {
        my $start_timestamp = _parse_005_timestamp( $start_timestamp, 0 );
        my $end_timestamp = _parse_005_timestamp( $end_timestamp, 1 );

        my $dtf = $schema->storage->datetime_parser;

        $extra_conditions{'import_record.upload_timestamp'} = {
            -between => [
                $dtf->format_datetime($start_timestamp),
                $dtf->format_datetime($end_timestamp)
            ]
        };
    }

    my $records = $schema->resultset('ImportBiblio')->search(
        {
            'import_record.import_batch_id' => $batch_id,
            %extra_conditions
        },
        {
            join => 'import_record',
        }
    );

    my $mimetype = 'application/octet-stream';
    my $charset  = 'utf-8';
    my $filename = DateTime->now->strftime("batch-$batch_id-%Y-%m-%d-%H-%M-%S.mrc");
    my $content_length = $records->get_column( { length => 'import_record.marc' } )->sum || 0;

    print $query->header(
        -type => $mimetype,
        -charset => $charset,
        -attachment => $filename,
        -Content_length => $content_length
    );

    for my $marc ( $records->get_column( 'import_record.marc' )->all ) {
        print $marc;
    }
}

sub get_record {
    my ( $batch_id, $import_record_id ) = @_;

    my $marcxml = GetImportRecordMarcXML( $import_record_id );

    if ( !$marcxml ) {
        C4::Service->return_error( 'not_found' );
    }

    $response->param( record => $marcxml );

    C4::Service->return_success( $response );
}

sub _control_number_already_used {
    my ( $marc_record, $batch_id, $import_record_id ) = @_;

    return unless ( $marc_record->field('001') );

    my %extra_conditions;

    $extra_conditions{'import_record.import_record_id'} = { '!=', $import_record_id } if ( $import_record_id );

    my $control_number = $marc_record->field('001')->data;

    my $schema = Koha::Database->new()->schema();
    return $schema->resultset('ImportBiblio')->count(
        {
            control_number => $control_number,
            'import_record.import_batch_id' => $batch_id,
            %extra_conditions
        },
        {
            join => 'import_record',
        }
    );
}

sub create_record {
    my ( $batch_id ) = @_;

    my $marcflavour = C4::Context->preference('marcflavour') || 'marc21';
    my $marc_record = eval { MARC::Record::new_from_xml( $query->param('record'), "utf8", $marcflavour) };
    if ($@) {
        C4::Service->return_error( 'failed', $@ );
    }

    if ( !$query->param('allow_control_number_conflict') && _control_number_already_used( $marc_record, $batch_id ) ) {
        C4::Service->return_error( 'control_number_match', '' );
    }

    my $import_record_id = AddBiblioToBatch( $batch_id, 0, $marc_record, "utf8", int( rand(99999) ) );
    $response->param( import_record_id => $import_record_id );

    C4::Service->return_success( $response );
}

sub update_record {
    my ( $batch_id, $import_record_id ) = @_;

    my $marcflavour = C4::Context->preference('marcflavour') || 'MARC21';
    my $marc_record = eval { MARC::Record::new_from_xml( $query->param('record'), "utf8", $marcflavour) };
    if ($@) {
        C4::Service->return_error( 'failed', $@ );
    }

    if ( !$query->param('allow_control_number_conflict') &&  _control_number_already_used( $marc_record, $batch_id, $import_record_id ) ) {
        C4::Service->return_error( 'control_number_match', '' );
    }

    C4::Biblio::UpdateMarcTimestamp( $marc_record );
    ModBiblioInBatch( $import_record_id, $marc_record );

    $response->param( updated_record => $marc_record->as_xml_record( C4::Context->preference('marcflavour') ) );

    C4::Service->return_success( $response );
}

sub create_batch {
    my ( $batch_name ) = C4::Service->require_params( 'batch_name' );

    my $batch_id = AddImportBatch({
        file_name => $batch_name,
        record_type => 'biblio'
    });

    $response->param( batch_id => $batch_id );

    C4::Service->return_success( $response );
}

C4::Service->dispatch(
    [ 'GET /(\d+)', [ 'download' ], \&download_batch ],
    [ 'GET /(\d+)/(\d+)', [], \&get_record ],
    [ 'POST /(\d+)/', [], \&create_record ],
    [ 'POST /(\d+)/(\d+)', [], \&update_record ],
    [ 'POST /', [], \&create_batch ],
);
